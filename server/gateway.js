const mongoose = require('mongoose');
const config = require('./config');
const Sensor = require('./models/Sensor'); // zapisuje do sensorLog

// P≈ôipojen√≠ k MongoDB Atlas
mongoose.connect(config.dbUri)
  .then(() => console.log('‚úÖ P≈ôipojeno k MongoDB Atlas'))
  .catch(err => console.error('‚ùå Chyba p≈ôi p≈ôipojen√≠ k MongoDB:', err));

// Model pro ƒçten√≠ z kolekce 'sensor1'
const sensor1Schema = new mongoose.Schema({
  temperature: Number,
  humidity: Number,
  soil_moisture: Number,
  light_level: Number,
  timestamp: String
});
const Sensor1 = mongoose.model('Sensor1', sensor1Schema, 'sensor1');

const INTERVAL_MINUTES = 5;
const STORAGE_DURATION_HOURS = 24;

// Z√≠sk√°n√≠ posledn√≠ho z√°znamu ze sensor1
async function fetchSensorData() {
  const count = await Sensor1.countDocuments(); 
  console.log('üì¶ Poƒçet dokument≈Ø v sensor1:', count);

  const last = await Sensor1.findOne().sort({ _id: -1 });
  console.log('üìÑ Posledn√≠ dokument:', last);

  if (!last) throw new Error('‚ö†Ô∏è ≈Ω√°dn√° data v kolekci sensor1');

  const data = last.toObject();

  return {
    temperature: data.temperature ?? 0,
    humidity: data.humidity ?? 0,
    soilMoisture: data.soil_moisture ?? 0,
    lightIntensity: data.light_level ?? 0,
    timestamp: data.timestamp ? new Date(data.timestamp) : new Date()
  };
}

// Ulo≈æen√≠ dat do sensorLog
async function storeData() {
  const data = await fetchSensorData();
  const entry = new Sensor(data);
  await entry.save();
  console.log(`üíæ Ulo≈æeno do sensorLog: ${data.timestamp.toISOString()}`);
}

// Smaz√°n√≠ star√Ωch z√°znam≈Ø v sensorLog
async function cleanupData() {
  const cutoff = new Date(Date.now() - STORAGE_DURATION_HOURS * 60 * 60 * 1000);
  const oldRecords = await Sensor.find({ timestamp: { $lt: cutoff } }).sort({ timestamp: 1 });

  if (oldRecords.length <= 2) return;

  const toDelete = oldRecords.slice(1, -1);
  const ids = toDelete.map(doc => doc._id);
  await Sensor.deleteMany({ _id: { $in: ids } });
  console.log(`üßπ Vymaz√°no ${ids.length} z√°znam≈Ø ze sensorLog`);
}

// Spu≈°tƒõn√≠ hlavn√≠ho cyklu
async function runGatewayCycle() {
  try {
    await storeData();
    await cleanupData();
  } catch (err) {
    console.error('‚ùå Chyba v gateway:', err.message);
  }
}

runGatewayCycle();
setInterval(runGatewayCycle, INTERVAL_MINUTES * 60 * 1000);